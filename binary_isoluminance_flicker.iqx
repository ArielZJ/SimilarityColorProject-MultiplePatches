<usermanual>
___________________________________________________________________________________________________________________
				HETEROCHROMATIC FLICKER: Determining isoluminant RGB values
___________________________________________________________________________________________________________________
Ariel Zeleznikow-Johnston
2021-08-27
ariel.zeleznikow-johnston@monash.edu

Modified from base Inquisit's "staircasemethod.iqx"
___________________________________________________________________________________________________________________
BACKGROUND INFO
This script implements a staircase method to find the point of minimal flicker using heterochromatic stimuli. This
enables the detection of R, G & B values that are perceptually isoluminant.

See https://www.researchgate.net/publication/300634510_Colour_vision_experimental_studies_in_teaching_of_optometry
for background details.

___________________________________________________________________________________________________________________
TASK DESCRIPTION	
___________________________________________________________________________________________________________________


___________________________________________________________________________________________________________________	
DURATION 
___________________________________________________________________________________________________________________	
About 2 minutes
___________________________________________________________________________________________________________________	
DATA FILE INFORMATION 
___________________________________________________________________________________________________________________

___________________________________________________________________________________________________________________	
INSTRUCTIONS 
___________________________________________________________________________________________________________________
see section Editable Instructions

___________________________________________________________________________________________________________________	
EDITABLE CODE 
___________________________________________________________________________________________________________________	


</usermanual>
**************************************************************************************************************
**************************************************************************************************************
	EDITABLE PARAMETERS: change editable parameters here
**************************************************************************************************************
**************************************************************************************************************

<parameters>
/responsekey_left = "F"
/responsekey_right = "J"

/same = "Y"
/different = "N"

/step = 50 // initial step value, gets reduced with each reversal

// increase for higher accuracy, slower calibration
/max_n_staircase = 6
/max_n_reversals = 4
/max_run_over = 2 // max times a participant can run off the edge
</parameters>

**************************************************************************************************************
**************************************************************************************************************
	EDITABLE INSTRUCTIONS: change instructions here
**************************************************************************************************************
**************************************************************************************************************

<item instructions>
/1 = "        Which circle was flickering less?"
/2 = "LEFT -> Press the '<%parameters.responsekey_left%>'
                                                                            RIGHT  -> Press the '<%parameters.responsekey_right%>'"
</item>


**************************************************************************************************************
**************************************************************************************************************
	DEFAULTS
**************************************************************************************************************
**************************************************************************************************************
script requires Inquisit 6.1.0.0 or higher


*******************************************************************************************************************
*******************************************************************************************************************
	DATA: this section contains data file information
*******************************************************************************************************************
*******************************************************************************************************************

********************
raw data
********************

*******************************************************************************************************************
*******************************************************************************************************************
	VALUES: automatically updated
*******************************************************************************************************************
*******************************************************************************************************************

<values>
//reversalthreshold = -999

/n_staircase = 0
/n_reversals = 0
/n_trials = -999

/temp_rev = -999

/stair_direction = -1 // staircase direction. -1 means down, 1 means up
/direction = -999 // trial direction 

/left_x = 30
/left_y = 50
/right_x = 80
/right_y = 50


/base_colour_R = 0
/base_colour_G = 0
/base_colour_B = 0
/left_colour_R = 0
/left_colour_G = 0
/left_colour_B = 0
/right_colour_R = 0
/right_colour_G = 0
/right_colour_B = 0

/generic_colour_current = -999
/generic_colour_previous = -999

/step = parameters.step

/n_flick = 0
/flicker_number = 8

/initial = true

/step_helper = 150

/run_over = 0 // quality control - count if participants overrun the bounds

/mode = "GB" // start with green vs. blue

/ReversalThreshold_GR = -999
/ReversalThreshold_GB = -999
/ReversalThreshold_RB = -999

/B_setting = 175
/Rnorm = -99.9
/Gnorm = -99.9
/Bnorm = -99.9
</values>

*******************************************************************************************************************
*******************************************************************************************************************
	EXPRESSIONS
*******************************************************************************************************************
*******************************************************************************************************************

<expressions>
/reversal_threshold = (values.generic_colour_current + values.generic_colour_previous)/2
</expressions>


*******************************************************************************************************************
*******************************************************************************************************************
	INSTRUCTIONS
*******************************************************************************************************************
*******************************************************************************************************************
<text taskinstruct1>
/items = instructions
/select = 1
/position = (50%, 10%)
/ fontstyle = ("Arial", 3%, true, false, false, false, 5, 1)
/ txcolor = black
</text>

<text taskinstruct2>
/items = instructions
/select = 2
/position = (50%, 20%)
/ fontstyle = ("Arial", 2%, false, false, false, false, 5, 1)
/ txcolor = black
</text>

<text luminant>
/items = ("Please verify these stimuli look equally luminant.
Press Y if they look equally bright.
Press N if some look brighter than others.")
/position = (50%, 85%)
/ fontstyle = ("Arial", 2%, false, false, false, false, 5, 1)
/ txcolor = white
/ txbgcolor = grey
</text>

<text colour_failure>
/items = ("Unfortunately the colour calibrations were unsuccessful.

Please press CTRL-Q to quit the experiment.")
/ fontstyle = ("Arial", 5%, false, false, false, false, 5, 1)
/position = (50%, 50%)
/ txcolor = black
/ txbgcolor = grey
</text>

*******************************************************************************************************************
*******************************************************************************************************************
	STIMULI
*******************************************************************************************************************
*******************************************************************************************************************
<shape base_left>
/shape = circle
/color = (values.base_colour_R, values.base_colour_G, values.base_colour_B)
/size = (30%*3/4, 30%)
/position = (values.left_x, values.left_y)
</shape>

<shape change_left>
/shape = circle
/color = (values.left_colour_R, values.left_colour_G, values.left_colour_B)
/size = (30%*3/4, 30%)
/position = (values.left_x, values.left_y)
</shape>

<shape base_right>
/shape = circle
/color = (values.base_colour_R, values.base_colour_G, values.base_colour_B)
/size = (30%*3/4, 30%)
/position = (values.right_x, values.right_y)
</shape>

<shape change_right>
/shape = circle
/color = (values.right_colour_R, values.right_colour_G, values.right_colour_B)
/size = (30%*3/4, 30%)
/position = (values.right_x, values.right_y)
</shape>

***********************************
Stimuli for the equiluminance check
***********************************

<shape stim1>
/shape = circle
/color = (floor( (0.5 *values.B_setting) * values.Rnorm),floor( (0.5 *values.B_setting) * values.Gnorm),floor((0.0 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (25,25)
</shape>

<shape stim2>
/shape = circle
/color = (floor((0.0 *values.B_setting) * values.Rnorm),floor( (0.5 *values.B_setting) * values.Gnorm),floor((0.5 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (50,25)
</shape>

<shape stim3>
/shape = circle
/color = (floor((0.5 *values.B_setting) * values.Rnorm),floor( (0.0 *values.B_setting) * values.Gnorm),floor((0.5 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (75,25)
</shape>

<shape stim4>
/shape = circle
/color = (floor((0.4 *values.B_setting) * values.Rnorm),floor( (0.6 *values.B_setting) * values.Gnorm),floor((0.0 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (25,50)
</shape>

<shape stim5> //problem
/shape = circle
/color = (floor((0.0 *values.B_setting)* values.Rnorm),floor( (0.4 *values.B_setting) * values.Gnorm),floor((0.6 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (50,50)
</shape>

<shape stim6> //problem
/shape = circle
/color = (floor((0.6 *values.B_setting) * values.Rnorm),floor( (0.0 *values.B_setting) * values.Gnorm),floor((0.4 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (75,50)
</shape>

<shape stim7>
/shape = circle
/color = (floor((0.6 *values.B_setting) * values.Rnorm),floor( (0.4 *values.B_setting) * values.Gnorm),floor((0.0 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (25,75)
</shape>

<shape stim8> //problem
/shape = circle
/color = (floor((0.0 *values.B_setting) * values.Rnorm),floor( (0.6 *values.B_setting) * values.Gnorm),floor((0.4 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (50,75)
</shape>

<shape stim9> //problem
/shape = circle
/color = (floor((0.4 *values.B_setting) * values.Rnorm),floor( (0.0 *values.B_setting) * values.Gnorm),floor((0.6 *values.B_setting) * values.Bnorm ))
/size = (10%*3/4, 10%)
/position = (75,75)
</shape>

*******************************************************************************************************************
*******************************************************************************************************************
	LISTS
*******************************************************************************************************************
*******************************************************************************************************************

// randomisation tools for trial selections


<list LR>
/items = ("L","R")
/ replace = true
/ selectionrate = trial
</list>

<list down_reversals_GR>
</list>
<list up_reversals_GR>
</list>

<list down_reversals_GB>
</list>
<list up_reversals_GB>
</list>

<list down_reversals_RB>
</list>
<list up_reversals_RB>
</list>

*******************************************************************************************************************
*******************************************************************************************************************
	TRIALS: run one interweaved staircase cycle
*******************************************************************************************************************
*******************************************************************************************************************
*************************************************
staircaseselection - pick an initial direction to go in, initiate staircase
*************************************************

<trial staircaseselection>
/ ontrialbegin = [
	// set the changing stimulus colour for the start of this staircase trial
	values.n_trials = 0;
	values.direction = values.stair_direction;
	if(values.mode == "GR"){
		values.base_colour_R = 255;
		values.base_colour_G = 0;
		values.base_colour_B = 0;
		
		if(values.direction == -1){ // down
			values.left_colour_G = 255;
			values.right_colour_G = 255;
			values.generic_colour_current = 255;
			values.generic_colour_previous = 255;
		} else{						// up
			values.left_colour_G = 0;
			values.right_colour_G = 0;
			values.generic_colour_current = 0;
			values.generic_colour_previous = 0;
		}
		values.left_colour_R = 0;
		values.left_colour_B = 0;
		values.right_colour_R = 0;
		values.right_colour_B = 0;
	} else if(values.mode == "GB"){
		values.base_colour_R = 0;
		values.base_colour_G = 0;
		values.base_colour_B = 255;
		
		if(values.direction == -1){
			values.left_colour_G = 255;
			values.right_colour_G = 255;
			values.generic_colour_current = 255;
			values.generic_colour_previous = 255;
		} else{
			values.left_colour_G = 0;
			values.right_colour_G = 0;
			values.generic_colour_current = 0;
			values.generic_colour_previous = 0;
		}
		values.left_colour_R = 0;
		values.left_colour_B = 0;
		values.right_colour_R = 0;
		values.right_colour_B = 0;
	} else if(values.mode == "RB"){
		values.base_colour_R = 0;
		values.base_colour_G = 0;
		values.base_colour_B = 255;
		
		if(values.direction == -1){
			values.left_colour_R = 255;
			values.right_colour_R = 255;
			values.generic_colour_current = 255;
			values.generic_colour_previous = 255;
		} else{
			values.left_colour_R = 0;
			values.right_colour_R = 0;
			values.generic_colour_current = 0;
			values.generic_colour_previous = 0;
		}
		values.left_colour_G = 0;
		values.left_colour_B = 0;
		values.right_colour_G = 0;
		values.right_colour_B = 0;
	}
]

/ trialduration = 0
/ ontrialend = [ // alternate the staircase direction for the next staircase
	if(values.stair_direction == -1){
		values.stair_direction = 1;
	} else{
		values.stair_direction = -1;
	}
]
// initiate the staircase, in the opposite direction to the last trial. Also stop if reversal number hit
/ branch = [
	// if participants are bad, throw them out
	if(values.run_over == parameters.max_run_over){
		trial.fail;
	}
	else if(values.n_staircase > parameters.max_n_staircase){ // go to next colour comparison if enough trials
		trial.thresholds;
	} else { // continue this colour comparison staircase
		trial.staircase; 
	}
]
</trial>

<trial fail>
/ stimulusframes = [1 = text.colour_failure]
/ trialduration = 60000;
</trial>

*************************************************
record intermediate & final reversal thresholds
*************************************************
//NOT CORRECT YET - MODIFY
<trial thresholds>
/ ontrialbegin = [
	if(values.mode == "GR"){
		values.ReversalThreshold_GR = (list.down_reversals_GR.median + list.up_reversals_GR.median) / 2;
	} else if(values.mode == "GB"){
		values.ReversalThreshold_GB = (list.down_reversals_GB.median + list.up_reversals_GB.median) / 2;
	} else if(values.mode == "RB"){
		values.ReversalThreshold_RB = (list.down_reversals_RB.median + list.up_reversals_RB.median) / 2;
	}
]

/trialduration = 0
/recorddata = true
/ branch = [
	// do the next colour
	if(values.mode=="GB"){
		values.mode = "RB";
		values.n_staircase = 0;
		trial.staircaseselection;
	}
]

</trial>

*************************************************
staircase - keep trials going until max_n_reversals reached
	initiate stimuli to be displayed, set relevant values
*************************************************

<trial staircase>
/ ontrialbegin = [
	// if it's the first trial, choose one of the stimuli randomly to get altered by one step
	if(values.n_trials == 0){
		// increment the value for one of the stimuli
		values.generic_colour_current = values.generic_colour_current + (values.step * values.direction);
		// set the stimuli
		if(list.LR.nextvalue == "L"){
			if(values.mode == "GB"){
				values.left_colour_G = values.generic_colour_current;
			} else if (values.mode == "RB"){
				values.left_colour_R = values.generic_colour_current;
			}
		} else if(list.LR.nextvalue == "R"){
			if(values.mode == "GB"){
				values.right_colour_G = values.generic_colour_current;
			} else if (values.mode == "RB"){
				values.right_colour_R = values.generic_colour_current;
			}
		}
	} else { // for subsequent trials, randomly set L/R equal to the last chosen stimulus, and increment the other one by a step
		values.generic_colour_current = values.generic_colour_previous + (values.step * values.direction); // update
		if(list.LR.nextvalue == "L"){ // set the left stimulus equal to that from the previous trial
			if(values.mode == "GB"){
				values.left_colour_G = values.generic_colour_previous;
				values.right_colour_G = values.generic_colour_current;
			} else if(values.mode == "RB"){
				values.left_colour_R = values.generic_colour_previous;
				values.right_colour_R = values.generic_colour_current;				
			}
		} else {
			if(values.mode == "GB"){
				values.right_colour_G = values.generic_colour_previous;
				values.left_colour_G = values.generic_colour_current;
			} else if(values.mode == "RB"){
				values.right_colour_R = values.generic_colour_previous;
				values.left_colour_R = values.generic_colour_current;				
			}
		}
	}
	values.n_trials += 1;
]
/ trialduration = 0;
/ branch = [
	// if they've run off the end, reset everything
	if( (values.generic_colour_current < 0) || (values.generic_colour_current > 255) ){
		values.run_over += 1;
		values.n_reversals = 0;
		values.step = parameters.step;
		trial.staircaseselection
	// otherwise, keep going
	} else if(values.n_reversals < parameters.max_n_reversals){ // keep going
		trial.flicker;
	} else { // send back to staircase selection if reversal number hit
		// record the current values and add them to the reversal threshold lists
		if(values.mode == "GB"){
			if(values.stair_direction == -1){
				list.down_reversals_GB.appenditem(expressions.reversal_threshold);
			} else{
				list.up_reversals_GB.appenditem(expressions.reversal_threshold);
			}
		} else if (values.mode =="RB"){
			if(values.stair_direction == -1){
				list.down_reversals_RB.appenditem(expressions.reversal_threshold);
			} else{
				list.up_reversals_RB.appenditem(expressions.reversal_threshold);
			}
		}
		// reset reversals for the trials
		values.n_reversals = 0;
		values.n_staircase += 1;
		values.step = parameters.step;
		trial.staircaseselection;
	}
]

</trial>

*************************************************
Flicker - flicker between base and changing stimulus
*************************************************
<trial flicker>
/ stimulusframes = [1=base_left,base_right;2=change_left,change_right]
/ trialduration = display.refreshinterval * 2; // hard coding trial to 2 frame duration
/ branch = [
	if( values.n_flick < values.flicker_number){ // set how long the flickering should continue
		values.n_flick += 1;
		return trial.flicker;
	} else {
		values.n_flick = 0;
		return trial.response;
	}
]
/ recorddata = false // testing

</trial>

*************************************************
Response - collect choice made about left or right stimulus having minimal flicker
*************************************************
<trial response>
/ stimulusframes = [1=taskinstruct1,taskinstruct2]
/ validresponse = (parameters.responsekey_left,parameters.responsekey_right)
/ ontrialbegin = [
	
]
/ ontrialend = [
	
	// to enable checking for a reversal
	if(values.mode == "GB"){
		if(trial.response.responsetext == parameters.responsekey_left){
			values.temp_rev = ((values.left_colour_G - values.right_colour_G) * values.direction * 1);
		} else {
			values.temp_rev = ((values.right_colour_G - values.left_colour_G) * values.direction * 1);
		}
	} else {
		if(trial.response.responsetext == parameters.responsekey_left){
			values.temp_rev = ((values.left_colour_R - values.right_colour_R) * values.direction * 1);
		} else {
			values.temp_rev = ((values.right_colour_R - values.left_colour_R) * values.direction * 1);
		}
	}
	//values.temp_rev = ((values.left_colour_G - values.right_colour_G) * values.direction * -1);
	

]
/ branch = [
	trial.update;
]
</trial>

// created to help keep track of changing parameters
<trial update>
/ trialduration = 0
/ ontrialbegin = [
	// update the selection of the previous trial's stimulus to be the one that was just selected
	if(values.mode == "GB"){
		if(trial.response.responsetext == parameters.responsekey_left){
			values.generic_colour_previous = values.left_colour_G;
		} else {
			values.generic_colour_previous = values.right_colour_G;
		}
	} else {
		if(trial.response.responsetext == parameters.responsekey_left){
			values.generic_colour_previous = values.left_colour_R;
		} else {
			values.generic_colour_previous = values.right_colour_R;
		}
	}

]
/ ontrialend = [
	// deal with if a participant ran off the end
	values.step_helper = values.generic_colour_previous + (values.step * values.direction);
	if( (values.step_helper < 0) || (values.step_helper > 255)){
		values.direction = -1 * values.direction; // reverse the direction for the next trial
	} else if( values.temp_rev < 0){ // register if a reversal just took place 
		values.n_reversals += 1;
		values.direction = -1 * values.direction; // reverse the direction for the next trial
		values.step = values.step/2; // decrease the step size
	}
]
/ branch = [
	trial.staircase;
]

</trial>

*************************************************
luminancedisplay - verify that reversal thresholds enable the creation of equiluminant stimuli
*************************************************

<trial luminancedisplay>
/ stimulusframes = [1=stim1,stim2,stim3,stim4,stim5,stim6,stim7,stim8,stim9,luminant]
/ validresponse = (parameters.same,parameters.different)
</trial>

*******************************************************************************************************************
*******************************************************************************************************************
	BLOCKS
*******************************************************************************************************************
*******************************************************************************************************************

*****************
Staircase
*****************

Note: block.staircase_XX runs one cycle of two interweaved staircases (one starting above and one starting below
basevalue) with parameters.baselinevalue1

To run further cycles, create separate blocks for each of the baselines.
change -> /onblockbegin = [values.baseline_value = values.baselinevalue2]
Go to EXPERIMENT and add the new  cycles

<block staircase>
/onblockbegin = [
	
	if(values.mode == "GR"){
		values.base_colour_R = 255;
		values.base_colour_G = 0;
		values.base_colour_B = 0;
	} else if(values.mode == "GB"){
		values.base_colour_R = 0;
		values.base_colour_G = 0;
		values.base_colour_B = 255;
	} else if(values.mode == "RB"){
		values.base_colour_R = 0;
		values.base_colour_G = 0;
		values.base_colour_B = 255;
	}
	
	//values.cycles += 1;
	//values.sum_diffthreshold_down = 0; 
	//values.sum_diffthreshold_up = 0;
	//values.countreversals_down = 0; 
	//values.countreversals_up = 0;
	//values.run_down = 0; 
	//values.run_up = 0;
	//values.baseline_value = parameters.baselinevalue1;
	//values.nextstaircase = list.randomstaircase.nextvalue;
]
/trials = [1=staircaseselection]
/onblockend = [
	//values.diffthreshold1 = expressions.diffthreshold;
]
</block>

*****************
Verification
*****************

luminance_check block runs a trial that asks for verification that the stimuli all appear to be of equivalent luminance
<block luminancedisplay>
/ onblockbegin = [
	// calculate & set renormalised R, G, B luminance values
	values.Rnorm = values.ReversalThreshold_RB / values.B_setting;
	values.Gnorm = values.ReversalThreshold_GB / values.B_setting;
	values.Bnorm = values.B_setting/values.B_setting;
]
/ trials = [1=luminancedisplay]

</block>

*******************************************************************************************************************
												End of File
*******************************************************************************************************************